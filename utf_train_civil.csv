"Hi,Thanks for the details.Initially i was sceptical of rst & once instead of hitting the fly,hit ""make htmldocs"" on the keyboard :), and the opinion about it waschanged. It was easy to navigate through various docs & the realizedthat various topics (& many) were present (yes, it was there earlieralso, but had to dive inside Documentation & search, while viewing thetoplevel index.html made them standout). It was like earlier you hadto go after docs, but now it was docs coming after you, that is myopinion.Later while fighting with memory-barriers.txt, felt that it might begood for it as well as to be in that company.And the readability as a text is not hurt as well.It was thought that rst conversion could be done quickly, but sincethis was my first attempt with rst, had to put some effort to get anot so bad output, even if this patch dies, i am happy to have learntrst conversion to some extent.When one of the author of the original document objected, i felt it isbetter to backoff. But if there is a consensus, i will proceed.afzal",Civil
,
"On Tue, Feb 27, 2018 at 8:54 PM, Dmitry Torokhov<dmitry.torokhov@gmail.com> wrote:Hi Dmitry - thanks for the review!okok - will have this in v2:// SPDX-License-Identifier: GPL-2.0//// Copyright (C) 2018 Gateworks Corporation//// This driver dispatches Linux input events for GSC interrupt events//oops, did not mean to submit thatit was for original debugging and not needed - will removeYes, that makes sense. I'll propose something like the following in v2:gsc_input {   compatible = ""gw,gsc-input"";   button {      label = ""user pushbutton"";      linux,code = <256>;      interrupts = <0>   };   key-erased {      label = ""key erased"";      linux,code = <257>;      interrupts = <1>   };   ...};right - thanks!I am using request_threaded_irq with thread_fn with thread_fn (vs handler).Do you mean why use a work procedure? I guess I don't need that andcan call input_report_key directly from the irq.okcan you point me to an example dts/driver?Tim",Civil
,
"Randy,No, at this point it requires both I2C and OF. I may add platform datato support an older non-device-tree family of boards but it stillwould require I2C.I will remove the || COMPILE_TESTThanks for catching that.Tim",Civil
,
"Guenter,Thanks for the review!oops - left that in by mistake.It has 16x ADC channels where some can be temperatures and others canbe voltage inputs (based on device tree).understood - a much cleaner patternright - removedyikes - thanks for catching thatokyes, that static arrays are not very forward-thinking and yes myarrays are not consistent. I'll convert to dynamically allocating thechannels for v2right - certainly an issuewill dowill add validationokDo you mean stuffing a u32 into a u8?will fixwill fixwill docould also return -EINVAL but not with the args I'm passing in so I'llchange it to:return PTR_ERR_OR_ZERO(hwmon);Thanks!Tim",Civil
,
"Sorry for being dense. What tree is this against? I can't find mentionof amdcz in Linus's tree nor linux-next.Where does serial8250_skip_old_ports get used where CONFIG_SERIAL_8250isn't defined? (i.e. why is the #ifdef needed here?)Otherwise, sure, sounds good. :)-Kees--Kees CookPixel Security",Civil
,
Can you possibly send the entire series again and CC all patches to linux-acpiand fix the kbuild warnings if the are relevant for that matter?Thanks!,Civil
,
"Hi YannickCan you add a commit message explaining why you add a specific defconfigfor this board. FYI, previously, the same defconfig was used for allSTM32F7 boards (ie /stm32f746-disco_defconfig).You will also need to resync with the last master branch regardingdefconfig content.ThanksPatrice",Civil
,
"This is indeed guaranteed. For FTRACE use case. If it's being called from FTRACE inrun time, this would mean there were long calls in this module section, which inturn means, get_module_plt() was called at least once for this module and thissection.This doesn't hold in general, though.In any case, if you insist, I can try to rework the whole stuff implementing module_finalize().--Best regards,Alexander Sverdlin.",Civil
,
"So make it fit by returning an unsigned int.--Regards/Gruss,    Boris.Good mailing practices for 400: avoid top-posting and trim the reply.",Civil
,
"Thank you so much for many style, formatting and other issues fixes and also forintegration of 'check_at_most_once' patch, it saved me several review iterations.Regarding free of sg in two error paths, you were correct.I fixed it by placing several error labels to differentiate each handling.I also noted that reqdata_arr[b].req was not released properly, this is also fixed.following is a diff of my fix based on your modifications.(I can send it in a patch format, but it doesn't include a fix for Eric Biggers comments)@@ -573,10 +573,9 @@ static void verity_verify_io(struct dm_verity_io *io)                        verity_bv_skip_block(v, io, &io->iter);                        continue;                }-                reqdata_arr[b].req = ahash_request_alloc(v->tfm, GFP_NOIO);                if (unlikely(reqdata_arr[b].req == NULL))-                       goto err_memfree;+                       goto err_mem_req;                ahash_request_set_tfm(reqdata_arr[b].req, v->tfm);                /* +1 for the salt buffer */@@ -586,7 +585,7 @@ static void verity_verify_io(struct dm_verity_io *io)                                   GFP_NOIO);                if (!sg) {                        DMERR_LIMIT(""%s: kmalloc_array failed"", __func__);-                       goto err_memfree;+                       goto err_mem_sg;                }                sg_init_table(sg, num_of_buffs);                // FIXME: if we 'err_memfree' (or continue;) below how does this sg get kfree()'d?@@ -595,7 +594,7 @@ static void verity_verify_io(struct dm_verity_io *io)                                          reqdata_arr[b].want_digest,                                          &reqdata_arr[b].fec_io, &is_zero);                if (unlikely(r < 0))-                       goto err_memfree;+                       goto err_mem;                if (is_zero) {                        /*@@ -605,7 +604,7 @@ static void verity_verify_io(struct dm_verity_io *io)                        r = verity_for_bv_block(v, io, &io->iter,                                                verity_bv_zero);                        if (unlikely(r < 0))-                               goto err_memfree;+                               goto err_mem;                        verity_cb_complete(iodata, r);                        continue;                }@@ -644,7 +643,11 @@ static void verity_verify_io(struct dm_verity_io *io)        }        return;-err_memfree:+err_mem:+       kfree(sg);+err_mem_sg:+       ahash_request_free(reqdata_arr[b].req);+err_mem_req:        /*         * reduce expected requests by the number of unsent         * requests, -1 accounting for the current block        atomic_sub(blocks - b - 1, &iodata->expected_reqs);        verity_cb_complete(iodata, -EIO);I took your modifications and working upon it.",Civil
,
"The driver is looking good!It looks like you've done some kind of review that we weren't allowedto see, which is a double edged sword - I might be asking about thingsthat you've already spoken about with someone else.I'm only just learning about PECI, but I do have some general comments below.I think just saying ASPEED PECI support is enough. That way if thenext ASPEED SoC happens to have PECI we don't need to update all ofthe help text :)Nit: we use ASPEED instead of AST in the upstream kernel to distingushfrom the aspeed sdk drivers. If you feel strongly about this then Iwon't insist you change.I know these come from the ASPEED sdk driver. Do we need them all?Could the above use regmap_read_poll_timeout instead?That looks like an endian swap. Can we do something like this? regmap_write(map, reg, cpu_to_be32p((void *)msg->tx_buff))Having #defines is frowned upon. I think print_hex_dump_debug will dowhat you want here.I find this hard to read. Use a few more lines to make it clear whatyour code is doing.Actually, the entire for loop is cryptic. I understand what it's doingnow. Can you rework it to make it more readable? You follow a similarpattern above in the write case.Given the regmap_read is always going to be a memory read on theaspeed, I can't think of a situation where the read will fail.On that note, is there a reason you are using regmap and not justaccessing the hardware directly? regmap imposes a number of pointerlookups and tests each time you do a read or write.Again, a memory mapped read won't fail. How about we check that theregmap is working once in your _probe() function, and assume it willcontinue working from there (or remove the regmap abstraction alltogether).All of this code is for debugging only. Do you want to put it behindsome kind of conditional?We have a framework for doing clocks in the kernel. Would it makesense to write a driver for this clock and add it todrivers/clk/clk-aspeed.c?The property is optional so I suggest we don't print a message if it'snot present. We certainly don't want to print a message saying""invalid"".The same comment applies to the other optional properties below.Can we probe in parallel? If not, putting a sleep in the _probe willhold up the rest of drivers from being able to do anything, and holdup boot.If you decide that you do need to probe here, please add a comment.(This is the wait for the clock to be stable?)This interrupt is only for the peci device. Why is it marked as shared?",Civil
,
"According to my comment on the other thread, this stands true in casethe child is managed by runtime PM as well.Otherwise this looks good to me.How about adding an additional patch on top taking into account theignore_children flag and folding that into the series, kind of as youalso suggested?My point is, we might as well take the opportunity to fix this rightaway, don't you think?[...]Kind regardsUffe",Civil
,
"I'm really sorry for this.could you please illustrate me what the kconfig & warning is?I didn'tget such warnings from 0-day.thanks,rui",Civil
,
"I'm not the one that added this switch statement (it has been there since2011) and I would be happy to remove it.  However could we please deferthis to v4.17 and merge the current set of Exynos thermal fixes/cleanups(they simplify the driver a lot and make ground for future changes)?Best regards,--Bartlomiej ZolnierkiewiczSamsung R&D Institute PolandSamsung Electronics",Civil
,
"Hello, Arvind.Thanks for your reply :)I admit I am not familiar with this driver.I did not know this driver is only loaded during system boot-up time,I thought this driver can be loaded as a kernel module (like manydrivers) after system booting.After knowing this, I admit my patch is not proper, sorry...Best wishes,Jia-Ju Bai",Civil
,
"Dear Takashi,Well, I am not sure. Could you please give me hints, how to debug thisfurther? Is there some debug flag?I am only aware of the Ftrace framework, but in my experience it alsoskews the timings quite a bit, so might not be the best choice.Kind regards,Paul",Civil
,
I see I've missed some obvious things that you've pointed out here. I'llmark these warnings as False Positives and take your points into accountfor the analysis of the rest of the Spectre issues reported by Smatch.Sorry for the noise and thanks for the feedback.Thanks--Gustavo,Civil
,
"Hi,Please, drop this series. Further analysis is required as it seems allthese are False Positives.Sorry for the noise.Thanks--Gustavo",Civil
,
"Em Tue, 24 Apr 2018 12:36:09 +0200Peter Zijlstra <peterz@infradead.org> escreveu:Peter,Thanks for a comprehensive explanation about that. It now makes moresense to me.Yeah, better to apply a fix to avoid the issue with VIDIOC_ENUM_FMT.Btw, on almost all media drivers, the implementation for enumeratingthe supported formats are the same (and we have a few other VIDOC_ENUM_fooioctls that usually do similar stuff): the V4L2 core calls a driver,with looks into an array, returning the results to the core.So, a fix like that should likely go to almost all media drivers(there are a lot of them!), and, for every new one, to take careto avoid introducing it again during patch review process.So, I'm wondering if are there any way to mitigate it inside thecore itself, instead of doing it on every driver, e. g. changingv4l_enum_fmt() implementation at v4l2-ioctl.Ok, a ""poor man"" approach would be to pass the array directly tothe core and let the implementation there to implement the arrayfetch logic, calling array_index_nospec() there, but I wonder ifare there any other way that won't require too much code churn.Thanks,Mauro",Civil
,
"Luc please don't submit such a huge number of patches all at one time.Also, please fix the indentation of the functions whose argumentsspan multiple lines as has been pointed out to you in patch feedback.Finally, make this a true patch series.  It is so much easier formaintainers to work with a set of changes all doing the same thing ifyou make them a proper patch series with an appropriate ""[PATCH 0/N] ...""header posting.Thank you.",Civil
,
"One of the basic questions/concerns I have is accounting for surplus hugepages in the default memory resource controller.  The existing huegtlbresource controller already takes hugetlbfs huge pages into account,including surplus pages.  This series would allow surplus pages to beaccounted for in the default  memory controller, or the hugetlb controlleror both.I understand that current mechanisms do not meet the needs of the aboveuse case.  The question is whether this is an appropriate way to approachthe issue.  My cgroup experience and knowledge is extremely limited, butit does not appear that any other resource can be controlled by multiplecontrollers.  Therefore, I am concerned that this may be going againstbasic cgroup design philosophy.It would be good to get comments from people more cgroup knowledgeable,and especially from those involved in the decision to do separate hugetlbcontrol.--Mike Kravetz",Civil
,
"I am sorry that I didn't join the discussion for the previous versionbut time just didn't allow that. So sorry if I am repeating somethingalready sorted out.There was a deliberate decision to keep hugetlb and ""normal"" memorycgroup controllers separate. Mostly because hugetlb memory is anartificial memory subsystem on its own and it doesn't fit into the restof memcg accounted memory very well. I believe we want to keep thatstatus quo.Well such a usecase requires an explicit configuration already. Eitherby using special wrappers or modifying the code. So I would argue thatyou have quite a good knowlege of the setup. If you need a greaterflexibility then just do not use hugetlb at all and rely on THP.[...]I do not really think this is a good idea. We really do not want to makethe current hugetlb code more complex than it is already. The currenthugetlb cgroup controller is simple and works at least somehow. I wouldnot add more on top unless there is a _really_ strong usecase behind.Please make sure to describe such a usecase in details before we evenstart considering the code.Well, then I would argue that you shouldn't use 64kB pages for yoursetup or allow THP for smaller sizes. Really hugetlb pages are by nomeans a substitute here.--Michal HockoSUSE Labs",Civil
,
"No problem, at the beginning, I only wanted to enable the strict. Doingthis involves that I have to remove pinctrl nodes for the pins which aregoing to be request through the gpiolib to avoid conflicts. These pinswere configured with bias-pull-up. That's why I try to add the biassupport.Thanks for the detailed answer about what you have in mind.Well, yes and not! As a consequence of enabling strict mode, I have tofind another way to configure the pins.Yes, I have noticed this issue.Right, I have spotted some drivers to fix.I will try to handle the ones related to the platforms I am using.RegardsLudovic",Civil
,
"I apologize for having confused.The hugetlb pages obtained from the pool do not waste the buddy pool. Onthe other hand, surplus hugetlb pages waste the buddy pool. Due to thisdifference in property, I thought it could be distinguished.Although my memcg knowledge is extremely limited, memcg is accounting forvarious kinds of pages obtained from the buddy pool by the task belongingto it. I would like to argue that surplus hugepage has specificity interms of obtaining from the buddy pool, and that it is specially permittedcharge requirements for memcg.It seems very strange that charge hugetlb page to memcg, but essentiallyit only charges the usage of the compound page obtained from the buddy pool,and even if that page is used as hugetlb page after that, memcg is notinterested in that.I will completely apologize if my way of thinking is wrong. It would begreatly appreciated if you could mention why we can not charge surplushugepages to memcg.I could not understand the intention of this question, sorry. When resizethe pool, I think that the number of surplus hugepages in use does notchange. Could you explain what you were concerned about?--Thanks,Tsukada",Civil
,
"On 2018/05/24 22:24, Michal Hocko wrote[...]> I do not see anything like that. adjust_pool_surplus is simply andAs you said, my patch did not consider handling when manipulating thepool. And even if that handling is done well, it will not be a validreason to charge surplus hugepage to memcg.[...]I understood the concept of memcg.[...]As you said, it must be an alien. Thanks to the interaction up to here,I understood that my solution is inappropriate. I will look for anotherway.Thank you for your kind explanation.--Thanks,Tsukada",Civil
,
"I'm not sure I understand what you intend here. If __sync_blockdevfails, then the error should have already been marked in sb->s_wb_err(via patch #6). We wouldn't want to record that again at syncfs time.Note that __sync_blockdev will return errors based on the legacyAS_EIO/AS_ENOSPC flags.We really do need to record it in the superblock as soon as possibleafter an error occurs. If we want to allow userland to eventually beable to scrape this value out of the kernel (as we discussed at LSF/MM)then we can't assume that it'll be doing any sort of syncfs callbeforehand.The main reason to push this down into the filesystems is to allow themcontrol over whether to report errors at syncfs time via the superblockerrseq_t or not. If we don't really care about allowing this to be anopt-in thing, then we could just take the patch that I sent on April17th:    [PATCH] fs: track per-sb writeback errors and report them to syncfsWe'd also want patch #6 from this series, I think, but that's more orless enough to implement this over all filesystems, assuming they usemapping_set_error to record writeback errors. I'm fine with eitherapproach.",Civil
,
"Hi AlexanderPlease don't top post. And wrap your lines at around 75 charactersLook closely at the two implementations. Look at whatmmd_phy_indirect() does. I _think_ these are identical. So don't addyour own helper, please use the core code.     Andrew",Civil
,
"Oops, sorry, I double posted patch 5. Please disregard the second one.Logan",Civil
,
"Well, clients not checking the error code made this harder to debug forsure, but removing the error code is a side effect and not what ishappening here (in fact someone should probably still go back and adderror checking because these functions can still return errors butthat's not really something I have time to do). After the next couplepatches, the clients will use this change to detect that there are noport numbers and handle things similarly to the way they did before theywere broken by the multiport changes.This is the opposite of what I've ever heard before. Having a commitmessage that explains what led up to this commit is a good thing andallows people debugging in the future to better understand the decisionsmade. People debugging commits will never find the 0/X cover letterwhich is just intended to introduce the series to reviewers and describechanges if the series is posted multiple times.No this is not a feature request. This is fixing a regression that brokepreviously working code in the only sensible way I can come up with. Ifyou have a better way to fix this, I'd be glad to hear it. But thisshould *not* be treated as a feature request.Logan",Civil
,
"The commit description is not quite correct.  What the NO_HIDE_STALEflag does is allow a discard request for those block devices which donot have the DISCARD_ZEROES_DATA flag.I will note that the FALLOC_FL_NO_HIDE_STALE flag is a bitcontroversial in linux-fsdevel.  I have a similar patch in the VFS inGoogle's internal data center kernel, as well as an internal patchwhich implements support for this flag in ext4.  However, the patchesare out of tree, because pretty much all of the file system developerswho work for enterpise distributions were against this functionality.I know of one other major cloud provider (in China) using thefunctionality as an out-of-tree patch, but with no one else speakingin favor of it, and everyone else NAK'ing the patch and enterprisedistro's saying they would revert the patch in their distro kernels,the compromise we came to was that the code point for NO_HIDE_STALE_FLwould be reserved so that users of the out-of-tree patches wouldn'tcollide with future fallocate flags; and I would stop trying to pushthe patches upstream.I have no idea how Darrick was able to get commit 25f4c41415e5upstream, but I guess it was less controversial for block devices thanfor file systems.So I'm certainly in favor of this patch landing in mainline, but youshould be aware that there may be some opposition to it.Cheers,					- Ted",Civil
,
I can't take patches without any changelog text at all :(,Civil
,
"As far as I can tell, the above is the whole reason for the patchset,yes?  To avoid confusing users.Is that sufficient?  Can we instead simplify their lives by providingbetter documentation or informative printks or better Kconfig text,etc?And who *are* the people who are performing this configuration?  Randomsystem administrators?  Linux distro engineers?  If the latter thenthey presumably aren't easily confused!In other words, I'm trying to understand how much benefit this patchsetwill provide to our users as a whole.",Civil
,
"Hopefully I'm not missing anything here, but this doesn't really make anysense. I'm not sure I explained myself as well as I thought I did. To behonest, I had to double check this about literally 20 times to make sure I wasactually understanding this issue correctly. Turns out I was missing a coupleof parts, so I'm going to try again at explaining this using a diagram thatshows the various threads running concurrentlySTART: Driver load       |       |       |           Thread 1        ----- output_poll_execute()                       |           drm_helper_hpd_irq_event()                       |                       |  Schedules â†’            Thread 2                       ----------------- nouveau_display_hpd_work()                    Finish                          |                                           pm_runtime_get_sync() <--- keeps GPU alive                                                    |                                                   ...                                                    |                       ------------------------------                <still Thread 2>             drm_helper_hpd_irq_event()                       |                       |         Schedules â†’                       ------------------------------                       |                         Thread 3Drop last RPM ref -v   |                   output_poll_execute()             pm_runtime_put_sync()                  |                       |             drm_dp_mst_topology_mgr_set_mst()                    Finish                          |                                                    |                               â† Schedules          |                       -----------------------------|                       |                            |                    Thread 4                        |                       |                            |          drm_dp_mst_link_probe_work()  drm_dp_mst_wait_tx_reply() <-- these wait on eachother                       |                            |                     this is normal                       |    Sideband transactions   |                       |    happen here, this is    |                       |    where timeouts happen   |                       |                            |                       |      5 seconds later...    | autosuspend delay kicks in                       |            ...             |                        |                       |                            |                     Thread 5                       |  Communication + timeouts  |                 pm_runtime_work                       |  are still happening here  |                        |                       |                            |           nouveau_pmops_runtime_suspend()                       |                            |                        |                       |  Success! We can enable    |                        |                       |        displays now!       |            drm_kms_helper_poll_disable()                       |                            |                        |                       |                 *Atomic commit begins*              |                       |                            |     <-------------     |                       | More sideband transactions |       Waiting on       |                       |          ......            |  output_poll_execute() |                       |                            |     <-------------     |                       |                  pm_runtime_get_sync()              |                       |                            |                        |                       |   -------------------->    |     ------------->     |                       |        Waiting on          |       Waiting on       |                       |     output_poll_exec()     |    suspend requests    |                       |   -------------------->    |     ------------->     |                       |                            |                        |                       ----------------------------------------------------->|                                                                         DEADLOCKphew. that took a LONG time to come up with.Anyway-that's why your explanation doesn't make sense: the deadlock ishappening because we're calling pm_runtime_get_sync(). If we were to make thatcall conditional (e.g. drm_kms_helper_is_poll_worker()), all that would meanis that we wouldn't grab any runtime power reference and the GPU wouldimmediately suspend once the atomic commit finished, as the suspend request inThread 5 would finally get unblocked and thus----suspend.Hopefully I explained that better this time, I'll definitely make sure toactually include that diagram in the patch. As for whether or not this patchis even the right solution, I will need to confirm that tommorrow (if youdon't think it is still, please feel free to say so!) because it's gettinglate here.Cheers!	Lyude--Cheers,	Lyude Paul",Civil
,
"Thanks a lot for all this work! It was long overdue and it is nice tosee the project finally getting to an end, after passing into so many hands!I am not sure I understand the purpose of this level here. As far as Iunderstand, you only have per-engine control whether you want to enableCG or not. What you call BLCG and SLCG levels just mean ""don't use theboot values, but rather use our values (taken from nvidia)"".Now, here comes the nasty part: NVIDIA only ever validated the bootvalues (I guess they are extremely safe ones), and the optimised values(the ones coming from your patch 2, 3, and 4 along with the level 3.I think introducing a single parameter that controls both CG, PG, andautomatic reclocking would be safer. For CG and PG, it would be aall-or-nothing (either boot values, or everything like nvidia).This message is a bit odd, whether we keep the notion of levels or not.Can you get rid of the mention of powergating given that this is notpart of this patchset?If you agree with having a single enable bit for CG, then a simple:""Clockgating status: (boot|optimized)"" would work perfectly.All this time, I thought these parameters were for power gating... Ialso did not expect that clock gating had to be disabled before we couldprogram them.Great find!Why introduce gk104_therm_new_? I can't find references to it in thispatch (outside of the function below) or in the following patches.As you even export this function, it looks like you used to use thisfunction in an earlier revision of this series.Aside from all these nitpicks, the approach is quite self contained andI like the following patches. Well done!Once we settle on the configuration parameter, I can give you my R-b :)Martin",Civil
,
"First of all, I was mistaken when I wrote above that a check for!drm_kms_helper_is_poll_worker() would solve the problem.  Sorry!It doesn't because the call to pm_runtime_get_sync() is not happeningin output_poll_execute() but in drm_dp_mst_link_probe_work().Looking once more at the three stack traces you've provided, we've got:- output_poll_execute() stuck waiting for fb_helper->lock  which is held by drm_dp_mst_link_probe_work()- rpm_suspend() stuck waiting for output_poll_execute() to finish- drm_dp_mst_link_probe_work() stuck waiting in rpm_resume()For the moment we can ignore the first task, i.e. output_poll_execute(),and focus on the latter two.As said I'm unfamiliar with MST but browsing through drm_dp_mst_topology.cI notice that drm_dp_mst_link_probe_work() is the ->work element indrm_dp_mst_topology_mgr() and is queued on HPD.  I further notice thatthe work item is flushed on ->runtime_suspend:nouveau_pmops_runtime_suspend()  nouveau_do_suspend()    nouveau_display_suspend()      nouveau_display_fini()        disp->fini() == nv50_display_fini()	  nv50_mstm_fini()	    drm_dp_mst_topology_mgr_suspend()	      flush_work(&mgr->work);And before the work item is flushed, the HPD source is quiesced.So it looks like drm_dp_mst_link_probe_work() can only ever runwhile the GPU is runtime resumed, it never runs while the GPU isruntime suspended.  This means that you don't have to acquire anyruntime PM references in or below drm_dp_mst_link_probe_work().Au contraire, you must not acquire any because it will deadlock whilethe GPU is runtime suspending.  If there are functions which arecalled from drm_dp_mst_link_probe_work() as well as from other contexts,and those other contexts need a runtime PM ref to be acquired,you need to acquire the runtime PM ref conditionally on not beingdrm_dp_mst_link_probe_work() (using the current_work() technique).Alternatively, move acquisition of the runtime PM ref further up inthe call chain to those other contexts.Right, that seems to be a bug nouveau_pmops_runtime_suspend():If a display is plugged in while the GPU is about to runtime suspend,the display may be lit up by output_poll_execute() but the GPU willthen nevertheless be powered off.I guess after calling drm_kms_helper_poll_disable() we should re-checkif a crtc has been activated.  This should have bumped the runtime PMrefcount and have_disp_power_ref should be true.  In that case, thenouveau_pmops_runtime_suspend() should return -EBUSY to abort theruntime_suspend.The same check seems necessary after flushing drm_dp_mst_link_probe_work():If the work item lit up a new display, all previous suspend steps needto be unwound and -EBUSY needs to be returned to the PM core.Communication with an MST hub exceeding the autosuspend timeout isjust one scenario where this bug manifests itself.BTW, drm_kms_helper_poll_disable() seems to be called twice in theruntime_suspend code path, once in nouveau_pmops_runtime_suspend()and a second time in nouveau_display_fini().A stupid question, I notice that nv50_display_fini() calls nv50_mstm_fini()only if encoder_type != DRM_MODE_ENCODER_DPMST.  Why isn't that == ?Thanks,Lukas",Civil
,
"Hi Dan,Just a blind shot, without going into details - could you please checkif led-sources property documented in the common LED bindings couldn'thelp here?--Best regards,Jacek Anaszewski",Civil
,
"Hi!This is better than my proposal. Thanks!								Pavel--(english) http://www.livejournal.com/~pavelmachek(cesky, pictures) http://atrey.karlin.mff.cuni.cz/~pavel/picture/horses/blog.html",Civil
,
"I welcome this feature, been wanting it for some time now. There issimply not enough support in /proc/PID/maps or smaps to get thisinformation. This is important to improve code and data layouts.I would like to see the following changes to your proposal:   - call it PERF_SAMPLE_DATA_PAGE_SIZEThat would allow two things:   1 - not tied to PERF_SAMPLE_ADDR   2 - Allow PERF_SAMPLE_CODE_PAGE_SIZE to be addedIn some measurements, you may just care about the distribution of accessesacross page sizes. No need to use double the buffer space to save the addressyou will not use.Layout is important for code as well, in fact, that's what most peoplewant first.Having a CODE_PAGE_SIZE is therefore useful. I am happy adding it on top on yourproposal. Note that PERF_SAMPLE_CODE_PAGE_SIZE would not have to be tiedto PEBS unlike DATA_PAGE_SIZE.Thanks.",Civil
,
"Lui Song,Am Montag, 20. August 2018, 08:09:05 CEST schrieb Liu Song:Please use your real name. 1st Signed-off-by and patch author should match.Good find! I'll queue this for the next fixes-pull-request.Thanks,//richard",Civil
,
"Denis Du <dudenis2000@yahoo.ca> writes:Sorry about being late, just returned home and am trying to get all thebacklogs under control.I remember the PPP standard is a bit cloudy about the possible issue,but the latter indeed exists (the PPP state machine was written directlyto STD-51). There is related (more visible in practice, though we aren'taffected) issue of ""active"" vs ""passive"" mode (hdlc_ppp.c is ""active"",and two ""passives"" wouldn't negotiate at all).Anyway the problem is real (though not very visible in practice,especially on relatively modern links rather than 300 or 1200 bps dialupconnections) and should be fixed. Looking at the patch, my firstimpression is it makes the code differ from STD-51 a little bit.On the other hand, perhaps applying it as is and forgetting about theissue is the way to go.Ideally, I think the negotiation failure should end up (optionally, inaddition to the current behavior) in some configurable sleep, thenthe negotiation should restart. If it's worth the effort at this point,I don't know.Perhaps I could look at this later, but no promises (this requirespulling on and setting up some legacy hardware).Anyway, since the patch is safe and can solve an existing problem:Acked-by: Krzysztof Halasa <khc@pm.waw.pl>--Krzysztof Halasa",Civil
,
"Hi, David:HowÂ  do you think my patch?As you see, KrzysztofÂ  think my patch is ok to be accepted.But if you have a better idea to fix it,I am glad to see it. Anyway, this issue have to be fixed.Denis DUDenis Du <dudenis2000@yahoo.ca> writes:Sorry about being late, just returned home and am trying to get all thebacklogs under control.I remember the PPP standard is a bit cloudy about the possible issue,but the latter indeed exists (the PPP state machine was written directlyto STD-51). There is related (more visible in practice, though we aren'taffected) issue of ""active"" vs ""passive"" mode (hdlc_ppp.c is ""active"",and two ""passives"" wouldn't negotiate at all).Anyway the problem is real (though not very visible in practice,especially on relatively modern links rather than 300 or 1200 bps dialupconnections) and should be fixed. Looking at the patch, my firstimpression is it makes the code differ from STD-51 a little bit.On the other hand, perhaps applying it as is and forgetting about theissue is the way to go.Ideally, I think the negotiation failure should end up (optionally, inaddition to the current behavior) in some configurable sleep, thenthe negotiation should restart. If it's worth the effort at this point,I don't know.Perhaps I could look at this later, but no promises (this requirespulling on and setting up some legacy hardware).Anyway, since the patch is safe and can solve an existing problem:Acked-by: Krzysztof Halasa <khc@pm.waw.pl>--Krzysztof Halasa",Civil
,
"Thanks for the review and apologies for the delay.Replies inlined below.[...]okok, this is all new stuff to me ... I suppose I should do it also forall the other new files I createBut what is the license for the documentation? It's not code, so GPLseems wrong. Creative commons?I just noticed a patch for checkpatch.pl about SPDX and asked the samequestion there.https://lkml.org/lkml/2018/2/2/365[...]ok[...]I'll move it to the Use section.[...]I will add a reference to the selftest file.In practice it can also work as example.ok, the example route should be more explicative.--thanks again for the review, igor",Civil
,
"Michal Hocko wrote:Then, I am wondering why we are holding mmap_sem when callingmigrate_pages() in existing code.http://elixir.free-electrons.com/linux/latest/source/mm/migrate.c#L1576Sorry, I missed that. If mmap_sem is not needed for migrate_pages(),please ignore this patch.--Best Regards,Yan Zi",Civil
,
Thanks for testing this and letting me know.greg k-h,Civil
,
"Cool. I would say this is done right.How about writing an i2c bus driver which sits directly on top ofanother i2c bus? Basically a one port i2c mux.The current mux code does not seem to directly allow it, since itcalls i2c_transfer() directly on the parent, where as you want it tocall your own i2c_transfer function. But maybe you could expended thecore mux code to allow the i2c_mux_core structure to contain a transferfunction?      Andrew",Civil
