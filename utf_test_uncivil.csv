"Hi BorisThe major feature close to USB is this one and it can be found in othersprotocols (standardization process).Just to close this topic I3C vs USB, IMO it's wrong to pass the messagethat the I3C is closer to USB than I2C even more because I3C support theI2C on the fly.Sorry, with the proliferation of sensors I cannot see a multi mastersensor network based on USB.Yes, we already talked about secondary master support.I would bet to do something like in i2c, we don't need the same level ofcomplexity found in USB.I agree with the controller folder but not with prefix. Please checkwhat is already in the kernel.In this case and taking what is already in the kernel it will bedrivers/i3c/{master, slave, dwc, other with the same architecture as dwc}.I miss to mention PCI but since the beginning refer the slave and thecommon part.Splitting the driver is something that soon or later I will have to do.If you prefer later I'm ok with that.I think this discussion is starting to be counterproductive with arguingof both parts. Unfortunately I don't see anyone given their inputs too.To be clear, the subsystem is nice and I working with daily. As I saidthis is something that I dealing now and I'm telling what I think thatis not correct.",Uncivil
,
"Hi Vitor,On Tue, 27 Nov 2018 11:50:53 +0000vitor <vitor.soares@synopsys.com> wrote:I think you didn't read my reply carefully. I'm not saying I3C == USB,I'm just saying that the way you interact with an I3C from a SW PoV isnot at all the same as you would do for an I2C device. Do you deny that?Looks like there's a misunderstanding here. The question is not whetherI3C will replace I2C or USB, of course it's meant to overcome thelimitations of I2C. I'm just pointing out that, if we have to exposeI3C devices, we should look at what other discoverable buses do (PCI,USB, ...), not what I2C does.There's a difference between a secondary master that waits for its timeto become the currrent master, and a secondary master that provides I3Cdevice features when it's acting as a slave (sensor, GPIOcontroller, ...). So far we focused on supporting the former. Ifthere's a need for the latter, then we should start thinking about theslave framework...Can you detail a bit more what you have in mind? I don't think we cando like I2C, simply because we need to expose a valid DCR +manuf-ID/PID so that other masters can bind the device to theappropriate driver on their side. Plus, if we're about to exposegeneric profiles, we likely don't want each I3C slave controller driverto do that on its own.If we mix everything in the same subdir, I'd like to have an easy wayto quickly identify those that are slave controllers and those that aremaster controllers. For the dual-role thing, maybe we can consider themas master (ones with advances slave features).Would you be okay with drivers/i3c/controllers/{designware,dw}/..., sothat you can have all designware drivers (for both slave and masterblocks) in the same dir?For those that are placed directly under drivers/i3c/controllers/...(because they only have one .c file), I'd like to keep a standardprefix.And again, I'm questioning the necessity of per-IP directories at theroot level. I'm not against per-IP directories, as long as they areclassified like other HW blocks: drivers/i3c/{master,slave}/<ip>/...No it's not vain, it's how we do discuss things in the community. I'mnot saying I'm always right, but I need to understand the problemsyou're trying to solve to take a decision, and I don't think youinitially gave all the details I needed to understand your PoV. That'sa bit clearer now, even if I still disagree on a few aspects.They will come.Come on! All I've seen so far are complaints on tiny details, itdefinitely doesn't prevent you from adding new features.Regards,Boris",Uncivil
,
"On Tue, 4 Dec 2018 00:34:20 +0000vitor <vitor.soares@synopsys.com> wrote:If you want. Actually that's the most interesting part for me:discussing how we want to support I3C slave controllers or mixedmaster/slave controllers. All the driver split we're talking abouthere is just bikeshedding.Ok.I don't see why. If the driver is simple enough to fit in one file,there's no reason to create a new subdir. You think your DW IP is socomplex and configurable that it requires several source files, fine,but please don't force others to do the same.Yes.You mean, inside a sub-folder (drivers/i3c/controllers/{vendor}/)? Itdepends what you do with those source files. If they are to be exposeddirectly as modules, then they should be prefixed(i3c-<role>-<vendor>.c). On the other hand, if you create a singlemodule out of several source files, source files don't need to beprefixed, as long as the resulting module as a proper prefix.I'm not saying the discussion is useless, just that it's happening waytoo early compared to the other things we should work on. If you wereadding support for slaves, and were doing this split as part of thispatch series explaining that part of the code between slave and mastercan be shared, then we wouldn't have this debate. But right now, you'retelling me that we need to split the DW driver to prepare for featuresthat have not even been discussed/proposed. That's what I'm complainingabout.",Uncivil
,
So I strongly disagree with this. Anybody that has trouble with 0/1 vsfalse/true needs to stay the heck away from C.I would suggest we delete that stupid coccinelle scripts that generatesthese pointless warns.,Uncivil
,
Not to mention that WARN is gramatically incorrect. We're not assigning'bool' to 0/1 but the other way around.What crap..,Uncivil
,
"Then those tools are broken per the C spec.The C language spec, specifies _Bool as an integer type wide enough toat least store 0 and 1.IOW, 0 and 1 are perfectly valid valus to assign to a _Bool.And fundamentally that has to be so. That's how computers work. 0 isfalse, 1 is true.The kernel is not the place to try and abstract such stuff, C is ourportable assembler. We muck with hardware, we'd better know how the heckit works.",Uncivil
,
"Note that this patch does *not* remove the nasty trap caused by the garbagein question - struct file can be freed before we even return from->unlocked_ioctl().  Could you describe in details the desired behaviourof this interface?How about grabbing the references to all victims (*before* screwing withksys_close()), sticking them into a structure with embedded callback_headand using task_work_add() on it, the callback doing those fput()?The callback would trigger before the return to userland, so observabletiming of the final close wouldn't be changed.  And it would avoid thekludges like this.Of course, the proper fix would require TARDIS and set of instruments fortreating severe case of retrocranial inversion, so that this ""ABI"" would'venever existed, but...",Uncivil
,
"What's advertisement there?Huch? Care to tell what's a lie instead of making bold statements?Thanks,	tglx",Uncivil
,
"""No problem here, no performance issues, nothing to be seen unless youare running VM.""Take a care to look at the patch I submitted?Lie:# A system with an up to date kernel is protected against attacks from# malicious user space applications.3GB system running 32bit kernel is not protected. Same is true for forreally big 64bit systems.If I do what dmesg suggests, this becomes untrue:# The Linux kernel contains a mitigation for this attack vector, PTE# inversion, which is permanently enabled and has no performance# impact.Limiting memory to 2GB _is_ going to have severe perfomance impact.								Pavelcommit 9664b4dabdb132433a6843aefe05814953f1342fAuthor: Pavel <pavel@ucw.cz>Date:   Thu Jan 3 00:48:40 2019 +0100    Ok, I guess L1TF was a lot of fun, and there was not time for a good    documentation.    There's admin guide that is written as an advertisment, and    unfortunately is slightly ""inaccurate"" at places (to the point of    lying).    Plus, I believe it should go to x86/ directory, as this is really    Intel issue, and not anything ARM (or RISC-V) people need to know.    Signed-off-by: Pavel Machek <pavel@ucw.cz>diff --git a/Documentation/admin-guide/l1tf.rst b/Documentation/admin-guide/l1tf.rstindex 9af9773..05c5422 100644--- a/Documentation/admin-guide/l1tf.rst+++ b/Documentation/admin-guide/l1tf.rst@@ -1,10 +1,11 @@ L1TF - L1 Terminal Fault ========================-L1 Terminal Fault is a hardware vulnerability which allows unprivileged-speculative access to data which is available in the Level 1 Data Cache-when the page table entry controlling the virtual address, which is used-for the access, has the Present bit cleared or other reserved bits set.+L1 Terminal Fault is a hardware vulnerability on most recent Intel x86+CPUs which allows unprivileged speculative access to data which is+available in the Level 1 Data Cache when the page table entry+controlling the virtual address, which is used for the access, has the+Present bit cleared or other reserved bits set. Affected processors -------------------@@ -76,12 +77,14 @@ Attack scenarios    deterministic and more practical.    The Linux kernel contains a mitigation for this attack vector, PTE-   inversion, which is permanently enabled and has no performance-   impact. The kernel ensures that the address bits of PTEs, which are not-   marked present, never point to cacheable physical memory space.--   A system with an up to date kernel is protected against attacks from-   malicious user space applications.+   inversion, which is permanently enabled and has no measurable+   performance impact in most configurations. The kernel ensures that+   the address bits of PTEs, which are not marked present, never point+   to cacheable physical memory space. On x86-32, this physical memory+   needs to be limited to 2GiB to make mitigation effective.++   Mitigation is present in kernels v4.19 and newer, and in+   recent -stable kernels. 2. Malicious guest in a virtual machine ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^--(english) http://www.livejournal.com/~pavelmachek(cesky, pictures) http://atrey.karlin.mff.cuni.cz/~pavel/picture/horses/blog.html",Uncivil
,
"Pavel,I agree that this statement is incorrect.Calling this a lie is a completly unjustified personal attack on those whospent quite a lot of time on writing up documentation in the firstplace. It's suggesting that this document was written with malicious intentand the purpose of deceiving someone. Care to explain why you are assumingthis to be the case?Sure. That still does not justify the ""changelog"" you provided.It's interesting that quite some people were actually happy about thatdocument. Sorry, that we weren't able to live up to your high standards.What is the advertisement part again?It's a document targeted at system administrators and it definitely shouldnot be burried somewhere in Documentation/x86. As there are more documentsbeing worked on for the other issues, I have a patch ready which moves thatstuff into a separate hardware vulnerabilites folder in the admin-guide.FWIW, to the best of my knowledge the documentation about writingchangelogs is neither incorrect nor is it optional to adhere to it.The 'Affected processors' section right below this is very clear about thisbeing an Intel only issue (for now). So what exactly is the point of thischange?On x86-32? That's incorrect, because there are a lot of x86-32 systemswhich are not affected. Also it has nothing to do with the bit-width of thehardware. A 32bit kernel booted on a 64bit capable CPU has the same issue.For further correctness, this needs to mention that !PAE enabled kernelscannot do PTE inversion at all.The 2G limitation is not a general limitation. The limitation depends onthe number of physical address bits supported by the cache (not the numberof physical addresss bits exposed as pins) and is definitely not hardcodedto 2G. Just because your machine emits the 2G number does not make ituniversally correct. On a system with 36bit physical address space thelimit is 32G and on some CPUs that's actually wrong as well, see:override_cache_bits().Quoting yourself:Where is the explanation for the 'really big 64bit systems' issue forcorrectness sake?Thanks,	tglx",Uncivil
,
"So how should it be called? I initally used less strong words, only toget ""Care to tell what's a lie instead of making bold statements?""back. Also look at the timing of the thread.Ok, now can we have that document updated to meet the standards?Making it very clear from the begining this is x86-only issue. Yes,you can kind-of figure it out from the next section... except forIntel StrongArm.Next sentence speaks about ""present bit"" of ""page table entry"". Thatmay be confusing for people familiar with other architectures, whichmay not have such bit. We should mention this is x86 before usingx86-specific terminology.Ok.I don't know the detailed limits for each system; what about this?Signed-off-by: Pavel Machek <pavel@ucw.cz>									Paveldiff --git a/Documentation/admin-guide/l1tf.rst b/Documentation/admin-guide/l1tf.rstindex 9af9773..cbf02a4 100644--- a/Documentation/admin-guide/l1tf.rst+++ b/Documentation/admin-guide/l1tf.rst@@ -1,10 +1,11 @@ L1TF - L1 Terminal Fault ========================-L1 Terminal Fault is a hardware vulnerability which allows unprivileged-speculative access to data which is available in the Level 1 Data Cache-when the page table entry controlling the virtual address, which is used-for the access, has the Present bit cleared or other reserved bits set.+L1 Terminal Fault is a hardware vulnerability on most recent Intel x86+CPUs which allows unprivileged speculative access to data which is+available in the Level 1 Data Cache when the page table entry+controlling the virtual address, which is used for the access, has the+Present bit cleared or other reserved bits set. Affected processors -------------------@@ -76,12 +77,15 @@ Attack scenarios    deterministic and more practical.    The Linux kernel contains a mitigation for this attack vector, PTE-   inversion, which is permanently enabled and has no performance-   impact. The kernel ensures that the address bits of PTEs, which are not-   marked present, never point to cacheable physical memory space.--   A system with an up to date kernel is protected against attacks from-   malicious user space applications.+   inversion, which has no measurable performance impact in most+   configurations. The kernel ensures that the address bits of PTEs,+   which are not marked present, never point to cacheable physical+   memory space. For mitigation to be effective, physical memory needs+   to be limited in some configurations.++   Mitigation is present in kernels v4.19 and newer, and in+   recent -stable kernels. PAE needs to be enabled for mitigation to+   work. 2. Malicious guest in a virtual machine ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^--(english) http://www.livejournal.com/~pavelmachek(cesky, pictures) http://atrey.karlin.mff.cuni.cz/~pavel/picture/horses/blog.html",Uncivil
,
"Pavel,You called it a lie from the very beginning or what do you think made metell you that? Here is what you said:Nice try.What is 'the standards'? Your's or is there a general agreement?It's pretty clear, but yes admittedly we forgot to mention that IntelStrongARM is not affected. That's truly important because its widelydeployed in the cloud space and elsewhere.X86 terminology? Care to check how pte_present() is implemented across thearchitectures? Most of them use the PRESENT bit naming convention, just afew use VALID. That's truly confusing and truly x86 specific.It's not about detailed limits for particular systems. It's about the waythe limit is determined on certain class of systems. And that can bededuced from the code.If you want to provide more accurate documentation then you better come upwith something which is helpful instead of completely useless blurb likethe below:How is the admin going to figure that out? What kind of systems might beaffected by this?No. The mitigation is available when the kernel provides it. Numbers areirrelevant because that documentation has to be applicable for stablekernels as well. And what is a recent -stable kernel?Also the PAE part needs to go to a completely different section.Thanks,	tglx",Uncivil
,
"Hi!Actually, I still call it a lie. Document clearly says that bug isfixed in non-virtualized cases, when in fact it depends on PAE andlimited memory.At this point I want you to fix it yourself. Lying about security bugsbeing fixed when they are not is not cool. I tried to be helpful andsubmit a patch, but I don't feel like you are cooperating on gettingthe patch applied.Best regards,								Pavel--DENX Software Engineering GmbH,      Managing Director: Wolfgang DenkHRB 165235 Munich, Office: Kirchenstr.5, D-82194 Groebenzell, Germany",Uncivil
,
"Again, no.",Uncivil
,
"I would drop this patch for being too ugly and if nothing else, for lackof users (epoll will no longer need dlock).Thanks,Davidlohr",Uncivil
,
"Since when is the cover letter mandatory?I understand that is helps for a complicated patch setto explain the problem and solution in the cover letter,but for this simple test case addition what's the point?And there is nothing forcing a cover letter inhttps://www.kernel.org/doc/html/v4.20/process/submitting-patches.htmlAlso double tags seams to be quite common for selftest.See git log tools/testing/selftests/Thanks,--Tadeusz",Uncivil
,
"I'm not sure that forcing a library on users is a good reason to break UAPI.The patch is going into the latest, but can also be backported on futurestables.I don't think ""not fixing it because it's not fixed yet"" is a goodreason to keep things the way they are. But maybe that's just me.Given that the structure has already been extended several times, thereis pretty much nothing to keep this from happening again and again.--Julien Gomes",Uncivil
,
"Thats a misleading statement.  We've never supported running newer applicationson older kernels, and no one is forcing anyone to use the lksctp-tools library,I was only suggesting that, if we were to support this compatibility, that mightbe a place to offer it.Its also worth noting that we have precident for this.  If you look at the gitlog, this particular structure has been extended about 6 times in the life ofsctp.Also misleading, as it assumes that we're not intentionally doing this.  I getwanting to support running applications built for newer kernels on olderkernels, but thats just not something that we do, and to say thats broken ismisleading.  Older applications are required to run on newer kernels, but notvice versa, which is what you are asking for.And yes, this patch can be backported to older stable kernels, but by that sametoken, so can the patches that extend the struct, which would also fix theproblem, while supporting the newer features, which seems to me to be the bettersolution for applications which are looking for that support.",Uncivil
,
"From: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>Date: Wed, 6 Feb 2019 18:37:54 -0200What a complete mess we have here.Use new socket option numbers next time, do not change the size and/orlayout of existing socket options.This whole thread, if you read it, is basically ""if we compatabilitythis way, that breaks, and if we do compatability this other way ohshit this other thing doesn't work.""I think we really need to specifically check for the difference sizesthat existed one by one, clear out the part not given by the user, andbackport this as far back as possible in a way that in the older kernelswe see if the user is actually trying to use the new features and if soerror out.Which, btw, is terrible behavior.  Newly compiled apps should work onolder kernels if they don't try to use the new features, and if theycan the ones that want to try to use the new features should be ableto fall back when that feature isn't available in a non-ambiguousand precisely defined way.The fact that the use of the new feature is hidden in the newstructure elements is really rotten.This patch, at best, needs some work and definitely a longer and moredetailed commit message.",Uncivil
,
"There probably is a decent compromise to find between ""not accepting asingle additional byte"" and accepting several GB.For example how likely is it that the growth of this structure make itgo over a page? I would hope not at all.By choosing a large but decent high limit, I think we can find afuture-compatible compromise that doesn't rely on a preliminarygetsockopt() just for structure trucation decision...--Julien Gomes",Uncivil
,
"I disagree with this, at least as a unilateral statement.  I would assert thatan old program, within the constraints of the issue being discussed here, willrun perfectly well, when built and run against a new kernel.At issue is the size of the structure sctp_event_subscribe, and the fact that inseveral instances over the last few years, its been extended to be larger andencompass more events to subscribe to.Nominally an application will use this structure (roughly) as follows:...struct sctp_event_subscribe events;size_t evsize = sizeof(events);memset(&events, 0, sizeof(events));events.sctp_send_failure_event = 1; /*example event subscription*/if (sctp_setsocktpt(sctp_fd, SOL_SCTP, SCTP_EVENTS, &events, &evsize) < 0) {	/* do error recovery */}....Assume this code will be built and run against kernel versions A and B, inwhich:A) has a struct sctp_event_subscribe with a size of 9 bytesB) has a struct sctp_event_subscribe with a size of 10 bytes (due to the addedfield sctp_sender_dry_event)That gives us 4 cases to handle1) Application build against kernel A and run on kernel A.  This works fine, thesizes of the struct in question will always match2) Application is built against kernel A and run on kernel B.  In this case,everything will work because the application passes a buffer of size 9, and thekernel accepts it, because it allows for buffers to be shorter than the currentstruct sctp_event_subscribe size. The kernel simply operates on the optionsavailable in the buffer.  The application is none the wiser, because it has noknoweldge of the new option, nor should it because it was built against kernelA, that never offered that option3) Application is built against kernel B and run on kernel B.  This works finefor the same reason as (1).4) Application is built against kernel B and run on kernel A.  This will breakbecause the application is passing a buffer that is larger than what the kernelexpects, and rightly so.   The application is passing in a buffer that isincompatible with what the running kernel expects.We could look into ways in which to detect the cases in which this might be'ok', but I don't see why we should bother, because at some point its still anerror to pass in an incompatible buffer.  In my mind this is no different thantrying to run a program that allocates hugepages on a kernel that doesn'tsupport hugepages (just to make up an example).  Applications built againstnewer kernel can't expect all the features/semantics/etc to be identical toolder kernels.It shouldn't.  Assuming you have a program built against headers from kernel B(above), if you set a field in the structure that only exists in kernel B, andtry to run it on kernel A, you will get an EINVAL return, which is correctbehavior because you are attempting to deliver information to the kernel thatkernel A (the running kernel) doesn't know about.  Thats correct behavior.I won't disagree about the niceness of versioning, but that ship has sailed.To be clear,  this is situation (1) above, and yeah, running on the kernel youbuilt your application against should always work from a compatibilitystandpoint.Yes, but this is alawys the case for structures that change.  If you have anapplication built against kernel (B), and uses structure fields that only existin that version of the kernel (and not earlier) will fail to compile when builtagainst kernel (A) headers, and thats expected.  This happens with any kernelapi that exists in a newer kernel but not an older kernel.Any time you make a system call to the kernel, you have to be prepared to handlethe resulting error condition, thats not unexpected.  To assume that a systemcall will always work is bad programming practice.Neil",Uncivil
,
"Looking more flexible does not make it more correct.Thanks,	tglx",Uncivil
